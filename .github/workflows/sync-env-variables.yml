# Sync non-sensitive env variables to GitHub Environments
# - Input selects target environment (development/staging/production)
# - Prefer environment-specific example (.env.<env>.example); fallback to .env.example
# - Filters out sensitive keys (PASSWORD/SECRET/TOKEN/KEY) — do not write Secrets here
name: Sync Env Variables From Example

on:
  workflow_dispatch:
  push:
    branches:
      - main
      - staging
      - development
    paths:
      - '.env.example'
      - '.env.*.example'

permissions:
  actions: write # allow github-script to call environment variables API
  contents: read # checkout repository to read example files

jobs:
  sync-variables:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      # Detect environment from changed files on push (prefer file-based over branch mapping)
      - name: Detect environment from changed files
        id: detect_files
        run: |
          git fetch --depth=2 || true
          base=$(git rev-parse HEAD~1 2>/dev/null || echo '')
          files=$( [ -n "$base" ] && git diff --name-only "$base" HEAD || git ls-files )
          env_name=""
          for cand in production staging development; do
            if echo "$files" | grep -q ".env.$cand.example"; then env_name="$cand"; break; fi
          done
          echo "env_name=$env_name" >> $GITHUB_OUTPUT

      # Determine environment: prefer manual input; otherwise map branch → environment
      - name: Resolve target environment name
        id: resolve_env
        uses: actions/github-script@v7
        with:
          script: |
            const fromFiles = `${{ steps.detect_files.outputs.env_name }}`.trim()
            let envName = fromFiles
            if (!envName) {
              const ref = context.ref
              if (ref === 'refs/heads/main') envName = 'production'
              else if (ref === 'refs/heads/staging') envName = 'staging'
              else envName = 'development'
            }
            core.setOutput('env_name', envName)

      # Pick environment-specific example file if present, else fallback
      - name: Resolve environment-specific example path
        id: resolve
        run: |
          FILE=".env.${{ steps.resolve_env.outputs.env_name }}.example"
          if [ -f "$FILE" ]; then
            echo "path=$FILE" >> $GITHUB_OUTPUT
          else
            echo "path=.env.example" >> $GITHUB_OUTPUT
          fi

      # Parse global example first (base layer)
      - name: Build non-sensitive payload from examples (Node)
        id: build_payload
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs')
            const path = require('path')
            const envFile = process.env.ENV_FILE_PATH
            const parse = (txt) => {
              const out = {}
              if (!txt) return out
              txt.split(/\r?\n/).forEach(line => {
                const s = line.trim()
                if (!s || s.startsWith('#')) return
                const i = s.indexOf('=')
                if (i < 0) return
                const key = s.slice(0, i).trim()
                const val = s.slice(i + 1).trim()
                if (/(PASSWORD|SECRET|TOKEN|KEY)/.test(key)) return
                out[key] = val
              })
              return out
            }
            const base = fs.existsSync('.env.example') ? parse(fs.readFileSync('.env.example', 'utf8')) : {}
            const extra = (envFile && fs.existsSync(envFile)) ? parse(fs.readFileSync(envFile, 'utf8')) : {}
            const payload = { ...base, ...extra }
            core.info(`Payload keys: ${Object.keys(payload).join(', ')}`)
            core.setOutput('json', JSON.stringify(payload))
        env:
          ENV_FILE_PATH: ${{ steps.resolve.outputs.path }}

      # Write variables to selected environment (env overrides global)
      - name: Sync variables to environment (env-specific overrides global)
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.ENV_ADMIN_TOKEN }}
          script: |
            const envName = process.env.ENV_NAME
            const payload = JSON.parse(process.env.PAYLOAD_JSON || '{}')
            const owner = context.repo.owner
            const repo = context.repo.repo
            core.info(`Target environment: ${envName}`)
            if (!envName) {
              core.setFailed('Resolved environment name is empty; aborting write')
              return
            }
            const headers = { 'X-GitHub-Api-Version': '2022-11-28', 'Accept': 'application/vnd.github+json' }
            const list = await github.request('GET /repos/{owner}/{repo}/environments/{environment_name}/variables', { owner, repo, environment_name: envName, headers })
            const existing = new Set((list.data.variables || []).map(v => v.name))
            for (const [name, value] of Object.entries(payload)) {
              if (existing.has(name)) {
                await github.request('PATCH /repos/{owner}/{repo}/environments/{environment_name}/variables/{name}', {
                  owner, repo, environment_name: envName, name, headers, value
                })
                core.info(`Updated variable ${name}`)
              } else {
                await github.request('POST /repos/{owner}/{repo}/environments/{environment_name}/variables', {
                  owner, repo, environment_name: envName, headers, name, value
                })
                core.info(`Created variable ${name}`)
              }
            }
        env:
          ENV_NAME: ${{ steps.resolve_env.outputs.env_name }}
          PAYLOAD_JSON: ${{ steps.build_payload.outputs.json }}

      - name: Verify environment variables
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.ENV_ADMIN_TOKEN }}
          script: |
            const envName = process.env.ENV_NAME
            const owner = context.repo.owner
            const repo = context.repo.repo
            const headers = { 'X-GitHub-Api-Version': '2022-11-28', 'Accept': 'application/vnd.github+json' }
            const res = await github.request('GET /repos/{owner}/{repo}/environments/{environment_name}/variables', { owner, repo, environment_name: envName, headers })
            core.info(`Environment '${envName}' has ${res.data.variables?.length ?? 0} variables after sync`)
        env:
          ENV_NAME: ${{ steps.resolve_env.outputs.env_name }}
