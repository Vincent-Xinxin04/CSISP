# 从示例环境变量文件同步非敏感变量到 GitHub Environment
# - 按分支或变更文件自动解析目标环境（development/staging/production）
# - 优先使用环境专用示例文件 (.env.<env>.example)，否则回退到 .env.example
# - 过滤掉敏感键（PASSWORD/SECRET/TOKEN/KEY），这里只同步非敏感配置，Secrets 仍需放在 GitHub Secrets 中
name: Sync Env Variables From Example

on:
  workflow_dispatch:
  push:
    branches:
      - main
      - staging
      - development
    paths:
      - '.env.example'
      - '.env.*.example'
      - '.github/workflows/sync-env-variables.yml'

permissions:
  actions: write
  contents: read

jobs:
  sync-variables:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      # 根据变更的 env 示例文件推断目标环境（优先使用文件命名，而不是直接映射分支）
      - name: Detect environment from changed files
        id: detect_files
        run: |
          git fetch --depth=2 || true
          base=$(git rev-parse HEAD~1 2>/dev/null || echo '')
          files=$( [ -n "$base" ] && git diff --name-only "$base" HEAD || git ls-files )
          env_name=""
          for cand in production staging development; do
            if echo "$files" | grep -q ".env.$cand.example"; then env_name="$cand"; break; fi
          done
          echo "env_name=$env_name" >> $GITHUB_OUTPUT

      # 解析目标环境名称：优先使用推断结果，否则根据分支映射到环境
      - name: Resolve target environment name
        id: resolve_env
        uses: actions/github-script@v7
        with:
          script: |
            const fromFiles = `${{ steps.detect_files.outputs.env_name }}`.trim()
            let envName = fromFiles
            if (!envName) {
              const ref = context.ref
              if (ref === 'refs/heads/main') envName = 'production'
              else if (ref === 'refs/heads/staging') envName = 'staging'
              else envName = 'development'
            }
            core.setOutput('env_name', envName)

      # 选择环境专用的示例文件（存在则用 .env.<env>.example，否则退回 .env.example）
      - name: Resolve environment-specific example path
        id: resolve
        run: |
          FILE=".env.${{ steps.resolve_env.outputs.env_name }}.example"
          if [ -f "$FILE" ]; then
            echo "path=$FILE" >> $GITHUB_OUTPUT
          else
            echo "path=.env.example" >> $GITHUB_OUTPUT
          fi

      # 解析示例环境变量文件（过滤敏感字段，只构建非敏感变量的 payload）
      - name: Build non-sensitive payload from examples (Node)
        id: build_payload
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs')
            const path = require('path')
            const envFile = process.env.ENV_FILE_PATH
            const parse = (txt) => {
              const out = {}
              if (!txt) return out
              txt.split(/\r?\n/).forEach(line => {
                const s = line.trim()
                if (!s || s.startsWith('#')) return
                const i = s.indexOf('=')
                if (i < 0) return
                const key = s.slice(0, i).trim()
                const val = s.slice(i + 1).trim()
                if (/(PASSWORD|SECRET|TOKEN|KEY)/.test(key)) return
                out[key] = val
              })
              return out
            }
            const base = fs.existsSync('.env.example') ? parse(fs.readFileSync('.env.example', 'utf8')) : {}
            const extra = (envFile && fs.existsSync(envFile)) ? parse(fs.readFileSync(envFile, 'utf8')) : {}
            const payload = { ...base, ...extra }
            core.info(`Payload keys: ${Object.keys(payload).join(', ')}`)
            core.setOutput('json', JSON.stringify(payload))
        env:
          ENV_FILE_PATH: ${{ steps.resolve.outputs.path }}

      # 将非敏感变量写入目标 Environment（不存在则创建，存在则更新）
      - name: Sync variables to environment (env-specific overrides global)
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.ENV_ADMIN_TOKEN }}
          script: |
            const envName = process.env.ENV_NAME
            const payload = JSON.parse(process.env.PAYLOAD_JSON || '{}')
            const owner = context.repo.owner
            const repo = context.repo.repo
            core.info(`Target environment: ${envName}`)
            if (!envName) {
              core.setFailed('Resolved environment name is empty; aborting write')
              return
            }
            const headers = { 'X-GitHub-Api-Version': '2022-11-28', 'Accept': 'application/vnd.github+json' }
            const list = await github.request('GET /repos/{owner}/{repo}/environments/{environment_name}/variables', { owner, repo, environment_name: envName, headers })
            const existing = new Set((list.data.variables || []).map(v => v.name))
            for (const [name, value] of Object.entries(payload)) {
              if (existing.has(name)) {
                await github.request('PATCH /repos/{owner}/{repo}/environments/{environment_name}/variables/{name}', {
                  owner, repo, environment_name: envName, name, headers, value
                })
                core.info(`Updated variable ${name}`)
              } else {
                try {
                  await github.request('POST /repos/{owner}/{repo}/environments/{environment_name}/variables', {
                    owner, repo, environment_name: envName, headers, name, value
                  })
                  core.info(`Created variable ${name}`)
                } catch (error) {
                  const status = error?.status ?? error?.response?.status
                  if (status === 409) {
                    core.info(`Variable ${name} already exists, updating instead`)
                    await github.request('PATCH /repos/{owner}/{repo}/environments/{environment_name}/variables/{name}', {
                      owner, repo, environment_name: envName, name, headers, value
                    })
                    core.info(`Updated variable ${name}`)
                  } else {
                    throw error
                  }
                }
              }
            }
        env:
          ENV_NAME: ${{ steps.resolve_env.outputs.env_name }}
          PAYLOAD_JSON: ${{ steps.build_payload.outputs.json }}

      # 验证目标 Environment 是否包含所有非敏感变量
      - name: Verify environment variables
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.ENV_ADMIN_TOKEN }}
          script: |
            const envName = process.env.ENV_NAME
            const owner = context.repo.owner
            const repo = context.repo.repo
            const headers = { 'X-GitHub-Api-Version': '2022-11-28', 'Accept': 'application/vnd.github+json' }
            const res = await github.request('GET /repos/{owner}/{repo}/environments/{environment_name}/variables', { owner, repo, environment_name: envName, headers })
            core.info(`Environment '${envName}' has ${res.data.variables?.length ?? 0} variables after sync`)
        env:
          ENV_NAME: ${{ steps.resolve_env.outputs.env_name }}
